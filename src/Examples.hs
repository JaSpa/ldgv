module Examples where

import Data.Map (fromList)


filenames = ["simple_recursion.ldgv", "add.ldgv", "simple.ldgv"]

examples = fromList [("simple_recursion.ldgv", "type End : ~unit = Unit\n\ntype SUMC : ~ssn =\n  ?(n : Nat)\n  natrec n\n  { !Int. End\n  , A. ?Int. A\n  }\n\ntype SUM : ~ssn =\n  !(n : Nat)\n  natrec n\n  { ?Int. End\n  , A. !Int. A\n  }\n\n\n\n\nval sum (ch_in : SUMC) : End =\n  let <n, ch> = recv ch_in in\n    (natrec n \n      { fn (m : Int) fn (c : !Int.End)\n        send c m\n      , n1 . A . (y : (m : Int) -> (a:A) -> End) .\n        fn (m: Int) fn (c : ?Int. A)\n        let <k,c> = recv c in\n        y (k + m) c\n      }\n    ) 0 ch\n\n-- sends the numbers n to 1\nval sendsum (ch_out : SUM) (n : Nat) : Int =\n  let ch = send ch_out n in\n  (natrec n\n  { fn (c : ?Int.End)\n        fst (recv c)\n  , n1 . A . (y : (a:A) -> Int) .\n        fn (c : !Int. A)\n        y (send c n1)\n  }) ch\n\n-- | the summation should be (n^2 + n) / 2 -> with 1000 it should return 500500\nval main =\n  let <a, b> = new SUMC in\n  let x = fork (sum a) in\n  sendsum b 10\n")
    , ("add.ldgv", "type SendInt : ! ~ssn = !Int. !Int. Unit\n\nval send2 (c: SendInt) =\n    let x = ((send c) 1) in\n    let y = ((send x) 42) in\n    ()\n\nval add2 (c1: dualof SendInt) =\n    let <m, c2> = recv c1 in\n    let <n, c3> = recv c2 in\n    (m + n)\n\nval main =\n    let <a, b> = (new SendInt) in\n    let a1 = fork (send2 a) in\n    add2 b\n")
    , ("simple.ldgv", "type End : ~unit = Unit\n\nval main = \n     let <a, b> = (new TClient) in\n     let y = fork (lServer b) in\n     ((lClient a) 42)\n\ntype EOS : ! ~un = {'EOS}\ntype End : ! ~unit = Unit\n\ntype TClient : ! ~ssn =\n  !( l : {'neg, 'add})\n  case l of\n  { 'neg : !Int. ?Int. ?EOS. End\n  , 'add : !Int. !Int. ?Int. ?EOS. End\n  }\n\ntype LClient : ! ~ssn =\n  !{'neg}. !Int. ?Int. ?EOS. End\n\nval lClient (d : TClient) (x : Int) : Int =\n    let d1 = (send d) 'neg in\n    let d2 = (send d1) x in\n    let <r,d3> = recv d2 in\n    let <xx,zz> = recv d3 in\n    r\n\ntype TServer : ! ~ssn =\n  ? ( x : { 'neg, 'add })\n  case x of\n    { 'neg : ?Int. !Int. !EOS. End\n    , 'add : ?Int. ?Int. !Int. !EOS. End\n    }\n\nval lServer (c : TServer) : End =\n\tlet < l , c1 > = recv c in\n\tlet < x , c2 > = recv c1 in\n\tcase l of\n\t{ 'neg :\n\t  let c3 = send c2 (-x) in\n\t  send c3 'EOS\n\t, 'add :\n\t  let < y , c3 > = recv c2 in\n\t  let c4 = send c3 (x + y) in\n\t  send c4 'EOS\n\t}\n")
    ]
